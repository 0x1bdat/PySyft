From 023a96938fc8cb27b070780452a7c54b3f9b8c15 Mon Sep 17 00:00:00 2001
From: George Muraru <murarugeorgec@gmail.com>
Date: Wed, 18 Aug 2021 14:23:37 +0100
Subject: [PATCH 1/1] Add implicit conversion

---
 packages/syft/src/syft/ast/klass.py           | 143 ++++++++++--------
 .../syft/src/syft/core/pointer/pointer.py     |   4 +-
 .../src/syft/core/tensor/smpc/mpc_tensor.py   |  29 +++-
 packages/syft/src/syft/lib/numpy/__init__.py  |   2 +
 4 files changed, 111 insertions(+), 67 deletions(-)

diff --git a/packages/syft/src/syft/ast/klass.py b/packages/syft/src/syft/ast/klass.py
index d524e2e03..c124ef483 100644
--- a/packages/syft/src/syft/ast/klass.py
+++ b/packages/syft/src/syft/ast/klass.py
@@ -40,7 +40,6 @@ from ..logger import warning
 from ..util import aggressive_set_attr
 from ..util import inherit_tags
 
-
 def _resolve_pointer_type(self: Pointer) -> Pointer:
     """Resolve pointer of the object.
 
@@ -107,67 +106,6 @@ def get_run_class_method(attr_path_and_name: str) -> CallableT:
         internal `attr_path_and_name` variable.
     """
 
-    def run_class_method(
-        __self: Any,
-        *args: Tuple[Any, ...],
-        **kwargs: Any,
-    ) -> object:
-        """Run remote class method and get pointer to returned object.
-
-        Args:
-            *args: Args list of class method.
-            **kwargs: Keyword args of class method.
-
-        Returns:
-            Pointer to object returned by class method.
-        """
-        # we want to get the return type which matches the attr_path_and_name
-        # so we ask lib_ast for the return type name that matches out
-        # attr_path_and_name and then use that to get the actual pointer klass
-        # then set the result to that pointer klass
-        return_type_name = __self.client.lib_ast.query(
-            attr_path_and_name
-        ).return_type_name
-        resolved_pointer_type = __self.client.lib_ast.query(return_type_name)
-        result = resolved_pointer_type.pointer_type(client=__self.client)
-
-        # QUESTION can the id_at_location be None?
-        result_id_at_location = getattr(result, "id_at_location", None)
-        if result_id_at_location is not None:
-            # first downcast anything primitive which is not already PyPrimitive
-            (
-                downcast_args,
-                downcast_kwargs,
-            ) = lib.python.util.downcast_args_and_kwargs(args=args, kwargs=kwargs)
-
-            # then we convert anything which isnt a pointer into a pointer
-            pointer_args, pointer_kwargs = pointerize_args_and_kwargs(
-                args=downcast_args,
-                kwargs=downcast_kwargs,
-                client=__self.client,
-                gc_enabled=False,
-            )
-
-            cmd = RunClassMethodAction(
-                path=attr_path_and_name,
-                _self=__self,
-                args=pointer_args,
-                kwargs=pointer_kwargs,
-                id_at_location=result_id_at_location,
-                address=__self.client.address,
-            )
-            __self.client.send_immediate_msg_without_reply(msg=cmd)
-
-        inherit_tags(
-            attr_path_and_name=attr_path_and_name,
-            result=result,
-            self_obj=__self,
-            args=args,
-            kwargs=kwargs,
-        )
-
-        return result
-
     def run_class_smpc_method(
         __self: Any,
         *args: Tuple[Any, ...],
@@ -243,6 +181,87 @@ def get_run_class_method(attr_path_and_name: str) -> CallableT:
 
         return result
 
+
+    def run_class_method(
+        __self: Any,
+        *args: Tuple[Any, ...],
+        **kwargs: Any,
+    ) -> object:
+        """Run remote class method and get pointer to returned object.
+
+        Args:
+            *args: Args list of class method.
+            **kwargs: Keyword args of class method.
+
+        Returns:
+            Pointer to object returned by class method.
+        """
+        # TODO: Do it for kwargs
+        for arg in args:
+            client = getattr(arg, "client", None)
+            if client is not None and client != __self.client:
+                from ..core.tensor.smpc.mpc_tensor import MPCTensor
+                parties = [client, __self.client]
+                # TODO: Replace seed_shares with actual numbers
+                # TODO: Find way to retrieve dataset information regarding the shape
+                new_self = MPCTensor(secret=__self, parties=parties, shape=(4000, 3), seed_shares=42)
+                new_arg = MPCTensor(secret = arg, parties=parties, shape=(4000, 3), seed_shares=52)
+
+                op_str = attr_path_and_name.rsplit(".", 1)[-1]
+                method = getattr(new_self, op_str, None)
+                if method is None:
+                    raise ValueError(f"Did not found method {op_str} on MPCTensor")
+
+                return method(new_arg)
+
+
+        # we want to get the return type which matches the attr_path_and_name
+        # so we ask lib_ast for the return type name that matches out
+        # attr_path_and_name and then use that to get the actual pointer klass
+        # then set the result to that pointer klass
+        return_type_name = __self.client.lib_ast.query(
+            attr_path_and_name
+        ).return_type_name
+        resolved_pointer_type = __self.client.lib_ast.query(return_type_name)
+        result = resolved_pointer_type.pointer_type(client=__self.client)
+
+        # QUESTION can the id_at_location be None?
+        result_id_at_location = getattr(result, "id_at_location", None)
+        if result_id_at_location is not None:
+            # first downcast anything primitive which is not already PyPrimitive
+            (
+                downcast_args,
+                downcast_kwargs,
+            ) = lib.python.util.downcast_args_and_kwargs(args=args, kwargs=kwargs)
+
+           # then we convert anything which isnt a pointer into a pointer
+            pointer_args, pointer_kwargs = pointerize_args_and_kwargs(
+                args=downcast_args,
+                kwargs=downcast_kwargs,
+                client=__self.client,
+                gc_enabled=False,
+            )
+
+            cmd = RunClassMethodAction(
+                path=attr_path_and_name,
+                _self=__self,
+                args=pointer_args,
+                kwargs=pointer_kwargs,
+                id_at_location=result_id_at_location,
+                address=__self.client.address,
+            )
+            __self.client.send_immediate_msg_without_reply(msg=cmd)
+
+        inherit_tags(
+            attr_path_and_name=attr_path_and_name,
+            result=result,
+            self_obj=__self,
+            args=args,
+            kwargs=kwargs,
+        )
+
+        return result
+
     # relative
     from ..core.node.common.action.smpc_action_message import MAP_FUNC_TO_ACTION
 
diff --git a/packages/syft/src/syft/core/pointer/pointer.py b/packages/syft/src/syft/core/pointer/pointer.py
index 6443584f0..57aae75a5 100644
--- a/packages/syft/src/syft/core/pointer/pointer.py
+++ b/packages/syft/src/syft/core/pointer/pointer.py
@@ -444,8 +444,8 @@ class Pointer(AbstractPointer):
                 timeout_secs = 30  # default if not explicitly set
 
             # relative
-            from ..node.domain.service import RequestAnswerMessage
-            from ..node.domain.service import RequestStatus
+            from ..node.common.node_service.request_answer.request_answer_service import RequestAnswerMessage
+            from ..node.common.node_service.request_receiver.request_receiver_messages import RequestStatus
 
             output_string = "> Waiting for Blocking Request: "
             output_string += f"  {self.id_at_location}"
diff --git a/packages/syft/src/syft/core/tensor/smpc/mpc_tensor.py b/packages/syft/src/syft/core/tensor/smpc/mpc_tensor.py
index d8184ef51..d37a3ee5a 100644
--- a/packages/syft/src/syft/core/tensor/smpc/mpc_tensor.py
+++ b/packages/syft/src/syft/core/tensor/smpc/mpc_tensor.py
@@ -76,6 +76,7 @@ class MPCTensor(PassthroughTensor):
             raise ValueError("Shares should not be None at this step")
 
         res = MPCTensor._mpc_from_shares(shares, parties)
+        self.parties = parties
 
         self.mpc_shape = shape
 
@@ -128,7 +129,7 @@ class MPCTensor(PassthroughTensor):
     ) -> List[ShareTensor]:
         shares = []
         for i, party in enumerate(parties):
-            if party == secret.client:
+            if secret and party == secret.client:
                 value = secret
             else:
                 value = None
@@ -174,7 +175,7 @@ class MPCTensor(PassthroughTensor):
         # TODO: It might be that the resulted shares (if we run any computation) might
         # not be available at this point
 
-        local_shares = [share.get_copy() for share in self.child]
+        local_shares = [share.get_copy(request_block=True) for share in self.child]
         is_share_tensor = isinstance(local_shares[0], ShareTensor)
 
         if is_share_tensor:
@@ -188,6 +189,8 @@ class MPCTensor(PassthroughTensor):
         #    result = result.decode()
         return result
 
+    get = reconstruct
+
     @staticmethod
     @lru_cache(maxsize=128)
     def __get_shape(
@@ -265,6 +268,23 @@ class MPCTensor(PassthroughTensor):
         Returns:
             MPCTensor. the operation "op_str" applied on "self" and "y"
         """
+        parties = None
+        if ispointer(y):
+            if y.client not in self.parties:
+                parties = self.parties + [y.client]
+            else:
+                parties = [party for party in self.parties]
+
+            # TODO: Extract info for y shape from somewhere
+            # We presume at the moment that it is the same shape
+            y = MPCTensor(secret=y, shape=self.mpc_shape)
+
+            shares = MPCTensor._get_shares_from_remote_secret(secret=None, parties=parties)
+            op = getattr(operator, op_str)
+            new_shares = [op(share1, share2) for share1, share2 in zip(self.child, shares)]
+            new_shares += shares[len(new_shares) - 1:]
+            new_self = MPCTensor(shares=new_shares, shape=self.mpc_shape, parties=parties)
+
         is_private = isinstance(y, MPCTensor)
 
         if is_private:
@@ -279,8 +299,11 @@ class MPCTensor(PassthroughTensor):
         else:
             y_shape = y.shape
 
+        if parties is None:
+            parties = self.parties
+
         shape = MPCTensor.__get_shape(op_str, self.mpc_shape, y_shape)
-        result = MPCTensor(shares=result, shape=shape)
+        result = MPCTensor(shares=result, shape=shape, parties=parties)
         return result
 
     def add(
diff --git a/packages/syft/src/syft/lib/numpy/__init__.py b/packages/syft/src/syft/lib/numpy/__init__.py
index 6cd8040c8..d148712ab 100644
--- a/packages/syft/src/syft/lib/numpy/__init__.py
+++ b/packages/syft/src/syft/lib/numpy/__init__.py
@@ -52,6 +52,8 @@ def create_ast(client: TypeAny = None) -> Globals:
         ("numpy.ndarray.byteswap", "numpy.ndarray"),
         ("numpy.ndarray.copy", "numpy.ndarray"),
         ("numpy.ndarray.view", "numpy.ndarray"),
+        ("numpy.ndarray.__add__", "numpy.ndarray"),
+        ("numpy.ndarray.sum", "numpy.ndarray"),
     ]
 
     add_modules(ast, modules)
-- 
2.25.1

